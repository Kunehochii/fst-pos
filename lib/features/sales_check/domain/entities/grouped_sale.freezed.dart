// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'grouped_sale.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$GroupedSaleItem {
  double get quantity => throw _privateConstructorUsedError;
  double get unitPrice => throw _privateConstructorUsedError;
  double get totalAmount => throw _privateConstructorUsedError;
  PaymentMethod get paymentMethod => throw _privateConstructorUsedError;
  bool get isSpecialPrice => throw _privateConstructorUsedError;
  bool get isDiscounted => throw _privateConstructorUsedError;
  double? get discountedPrice => throw _privateConstructorUsedError;
  DateTime get saleDate => throw _privateConstructorUsedError;
  String get formattedSale => throw _privateConstructorUsedError;

  /// Create a copy of GroupedSaleItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GroupedSaleItemCopyWith<GroupedSaleItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GroupedSaleItemCopyWith<$Res> {
  factory $GroupedSaleItemCopyWith(
          GroupedSaleItem value, $Res Function(GroupedSaleItem) then) =
      _$GroupedSaleItemCopyWithImpl<$Res, GroupedSaleItem>;
  @useResult
  $Res call(
      {double quantity,
      double unitPrice,
      double totalAmount,
      PaymentMethod paymentMethod,
      bool isSpecialPrice,
      bool isDiscounted,
      double? discountedPrice,
      DateTime saleDate,
      String formattedSale});
}

/// @nodoc
class _$GroupedSaleItemCopyWithImpl<$Res, $Val extends GroupedSaleItem>
    implements $GroupedSaleItemCopyWith<$Res> {
  _$GroupedSaleItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GroupedSaleItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? quantity = null,
    Object? unitPrice = null,
    Object? totalAmount = null,
    Object? paymentMethod = null,
    Object? isSpecialPrice = null,
    Object? isDiscounted = null,
    Object? discountedPrice = freezed,
    Object? saleDate = null,
    Object? formattedSale = null,
  }) {
    return _then(_value.copyWith(
      quantity: null == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as double,
      unitPrice: null == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as double,
      totalAmount: null == totalAmount
          ? _value.totalAmount
          : totalAmount // ignore: cast_nullable_to_non_nullable
              as double,
      paymentMethod: null == paymentMethod
          ? _value.paymentMethod
          : paymentMethod // ignore: cast_nullable_to_non_nullable
              as PaymentMethod,
      isSpecialPrice: null == isSpecialPrice
          ? _value.isSpecialPrice
          : isSpecialPrice // ignore: cast_nullable_to_non_nullable
              as bool,
      isDiscounted: null == isDiscounted
          ? _value.isDiscounted
          : isDiscounted // ignore: cast_nullable_to_non_nullable
              as bool,
      discountedPrice: freezed == discountedPrice
          ? _value.discountedPrice
          : discountedPrice // ignore: cast_nullable_to_non_nullable
              as double?,
      saleDate: null == saleDate
          ? _value.saleDate
          : saleDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      formattedSale: null == formattedSale
          ? _value.formattedSale
          : formattedSale // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GroupedSaleItemImplCopyWith<$Res>
    implements $GroupedSaleItemCopyWith<$Res> {
  factory _$$GroupedSaleItemImplCopyWith(_$GroupedSaleItemImpl value,
          $Res Function(_$GroupedSaleItemImpl) then) =
      __$$GroupedSaleItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double quantity,
      double unitPrice,
      double totalAmount,
      PaymentMethod paymentMethod,
      bool isSpecialPrice,
      bool isDiscounted,
      double? discountedPrice,
      DateTime saleDate,
      String formattedSale});
}

/// @nodoc
class __$$GroupedSaleItemImplCopyWithImpl<$Res>
    extends _$GroupedSaleItemCopyWithImpl<$Res, _$GroupedSaleItemImpl>
    implements _$$GroupedSaleItemImplCopyWith<$Res> {
  __$$GroupedSaleItemImplCopyWithImpl(
      _$GroupedSaleItemImpl _value, $Res Function(_$GroupedSaleItemImpl) _then)
      : super(_value, _then);

  /// Create a copy of GroupedSaleItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? quantity = null,
    Object? unitPrice = null,
    Object? totalAmount = null,
    Object? paymentMethod = null,
    Object? isSpecialPrice = null,
    Object? isDiscounted = null,
    Object? discountedPrice = freezed,
    Object? saleDate = null,
    Object? formattedSale = null,
  }) {
    return _then(_$GroupedSaleItemImpl(
      quantity: null == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as double,
      unitPrice: null == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as double,
      totalAmount: null == totalAmount
          ? _value.totalAmount
          : totalAmount // ignore: cast_nullable_to_non_nullable
              as double,
      paymentMethod: null == paymentMethod
          ? _value.paymentMethod
          : paymentMethod // ignore: cast_nullable_to_non_nullable
              as PaymentMethod,
      isSpecialPrice: null == isSpecialPrice
          ? _value.isSpecialPrice
          : isSpecialPrice // ignore: cast_nullable_to_non_nullable
              as bool,
      isDiscounted: null == isDiscounted
          ? _value.isDiscounted
          : isDiscounted // ignore: cast_nullable_to_non_nullable
              as bool,
      discountedPrice: freezed == discountedPrice
          ? _value.discountedPrice
          : discountedPrice // ignore: cast_nullable_to_non_nullable
              as double?,
      saleDate: null == saleDate
          ? _value.saleDate
          : saleDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      formattedSale: null == formattedSale
          ? _value.formattedSale
          : formattedSale // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GroupedSaleItemImpl extends _GroupedSaleItem {
  const _$GroupedSaleItemImpl(
      {required this.quantity,
      required this.unitPrice,
      required this.totalAmount,
      required this.paymentMethod,
      required this.isSpecialPrice,
      required this.isDiscounted,
      this.discountedPrice,
      required this.saleDate,
      required this.formattedSale})
      : super._();

  @override
  final double quantity;
  @override
  final double unitPrice;
  @override
  final double totalAmount;
  @override
  final PaymentMethod paymentMethod;
  @override
  final bool isSpecialPrice;
  @override
  final bool isDiscounted;
  @override
  final double? discountedPrice;
  @override
  final DateTime saleDate;
  @override
  final String formattedSale;

  @override
  String toString() {
    return 'GroupedSaleItem(quantity: $quantity, unitPrice: $unitPrice, totalAmount: $totalAmount, paymentMethod: $paymentMethod, isSpecialPrice: $isSpecialPrice, isDiscounted: $isDiscounted, discountedPrice: $discountedPrice, saleDate: $saleDate, formattedSale: $formattedSale)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GroupedSaleItemImpl &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.unitPrice, unitPrice) ||
                other.unitPrice == unitPrice) &&
            (identical(other.totalAmount, totalAmount) ||
                other.totalAmount == totalAmount) &&
            (identical(other.paymentMethod, paymentMethod) ||
                other.paymentMethod == paymentMethod) &&
            (identical(other.isSpecialPrice, isSpecialPrice) ||
                other.isSpecialPrice == isSpecialPrice) &&
            (identical(other.isDiscounted, isDiscounted) ||
                other.isDiscounted == isDiscounted) &&
            (identical(other.discountedPrice, discountedPrice) ||
                other.discountedPrice == discountedPrice) &&
            (identical(other.saleDate, saleDate) ||
                other.saleDate == saleDate) &&
            (identical(other.formattedSale, formattedSale) ||
                other.formattedSale == formattedSale));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      quantity,
      unitPrice,
      totalAmount,
      paymentMethod,
      isSpecialPrice,
      isDiscounted,
      discountedPrice,
      saleDate,
      formattedSale);

  /// Create a copy of GroupedSaleItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GroupedSaleItemImplCopyWith<_$GroupedSaleItemImpl> get copyWith =>
      __$$GroupedSaleItemImplCopyWithImpl<_$GroupedSaleItemImpl>(
          this, _$identity);
}

abstract class _GroupedSaleItem extends GroupedSaleItem {
  const factory _GroupedSaleItem(
      {required final double quantity,
      required final double unitPrice,
      required final double totalAmount,
      required final PaymentMethod paymentMethod,
      required final bool isSpecialPrice,
      required final bool isDiscounted,
      final double? discountedPrice,
      required final DateTime saleDate,
      required final String formattedSale}) = _$GroupedSaleItemImpl;
  const _GroupedSaleItem._() : super._();

  @override
  double get quantity;
  @override
  double get unitPrice;
  @override
  double get totalAmount;
  @override
  PaymentMethod get paymentMethod;
  @override
  bool get isSpecialPrice;
  @override
  bool get isDiscounted;
  @override
  double? get discountedPrice;
  @override
  DateTime get saleDate;
  @override
  String get formattedSale;

  /// Create a copy of GroupedSaleItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GroupedSaleItemImplCopyWith<_$GroupedSaleItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PaymentTotals {
  double get cash => throw _privateConstructorUsedError;
  double get check => throw _privateConstructorUsedError;
  double get bankTransfer => throw _privateConstructorUsedError;

  /// Create a copy of PaymentTotals
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PaymentTotalsCopyWith<PaymentTotals> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentTotalsCopyWith<$Res> {
  factory $PaymentTotalsCopyWith(
          PaymentTotals value, $Res Function(PaymentTotals) then) =
      _$PaymentTotalsCopyWithImpl<$Res, PaymentTotals>;
  @useResult
  $Res call({double cash, double check, double bankTransfer});
}

/// @nodoc
class _$PaymentTotalsCopyWithImpl<$Res, $Val extends PaymentTotals>
    implements $PaymentTotalsCopyWith<$Res> {
  _$PaymentTotalsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PaymentTotals
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cash = null,
    Object? check = null,
    Object? bankTransfer = null,
  }) {
    return _then(_value.copyWith(
      cash: null == cash
          ? _value.cash
          : cash // ignore: cast_nullable_to_non_nullable
              as double,
      check: null == check
          ? _value.check
          : check // ignore: cast_nullable_to_non_nullable
              as double,
      bankTransfer: null == bankTransfer
          ? _value.bankTransfer
          : bankTransfer // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PaymentTotalsImplCopyWith<$Res>
    implements $PaymentTotalsCopyWith<$Res> {
  factory _$$PaymentTotalsImplCopyWith(
          _$PaymentTotalsImpl value, $Res Function(_$PaymentTotalsImpl) then) =
      __$$PaymentTotalsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double cash, double check, double bankTransfer});
}

/// @nodoc
class __$$PaymentTotalsImplCopyWithImpl<$Res>
    extends _$PaymentTotalsCopyWithImpl<$Res, _$PaymentTotalsImpl>
    implements _$$PaymentTotalsImplCopyWith<$Res> {
  __$$PaymentTotalsImplCopyWithImpl(
      _$PaymentTotalsImpl _value, $Res Function(_$PaymentTotalsImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentTotals
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cash = null,
    Object? check = null,
    Object? bankTransfer = null,
  }) {
    return _then(_$PaymentTotalsImpl(
      cash: null == cash
          ? _value.cash
          : cash // ignore: cast_nullable_to_non_nullable
              as double,
      check: null == check
          ? _value.check
          : check // ignore: cast_nullable_to_non_nullable
              as double,
      bankTransfer: null == bankTransfer
          ? _value.bankTransfer
          : bankTransfer // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$PaymentTotalsImpl extends _PaymentTotals {
  const _$PaymentTotalsImpl(
      {required this.cash, required this.check, required this.bankTransfer})
      : super._();

  @override
  final double cash;
  @override
  final double check;
  @override
  final double bankTransfer;

  @override
  String toString() {
    return 'PaymentTotals(cash: $cash, check: $check, bankTransfer: $bankTransfer)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentTotalsImpl &&
            (identical(other.cash, cash) || other.cash == cash) &&
            (identical(other.check, check) || other.check == check) &&
            (identical(other.bankTransfer, bankTransfer) ||
                other.bankTransfer == bankTransfer));
  }

  @override
  int get hashCode => Object.hash(runtimeType, cash, check, bankTransfer);

  /// Create a copy of PaymentTotals
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentTotalsImplCopyWith<_$PaymentTotalsImpl> get copyWith =>
      __$$PaymentTotalsImplCopyWithImpl<_$PaymentTotalsImpl>(this, _$identity);
}

abstract class _PaymentTotals extends PaymentTotals {
  const factory _PaymentTotals(
      {required final double cash,
      required final double check,
      required final double bankTransfer}) = _$PaymentTotalsImpl;
  const _PaymentTotals._() : super._();

  @override
  double get cash;
  @override
  double get check;
  @override
  double get bankTransfer;

  /// Create a copy of PaymentTotals
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PaymentTotalsImplCopyWith<_$PaymentTotalsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GroupedSale {
  /// Display name for the group (e.g., "Rice 50 KG")
  String get productName => throw _privateConstructorUsedError;

  /// Individual sale items in this group
  List<GroupedSaleItem> get items => throw _privateConstructorUsedError;

  /// Total quantity sold
  double get totalQuantity => throw _privateConstructorUsedError;

  /// Total amount for this group
  double get totalAmount => throw _privateConstructorUsedError;

  /// Payment method breakdown
  PaymentTotals get paymentTotals => throw _privateConstructorUsedError;

  /// Create a copy of GroupedSale
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GroupedSaleCopyWith<GroupedSale> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GroupedSaleCopyWith<$Res> {
  factory $GroupedSaleCopyWith(
          GroupedSale value, $Res Function(GroupedSale) then) =
      _$GroupedSaleCopyWithImpl<$Res, GroupedSale>;
  @useResult
  $Res call(
      {String productName,
      List<GroupedSaleItem> items,
      double totalQuantity,
      double totalAmount,
      PaymentTotals paymentTotals});

  $PaymentTotalsCopyWith<$Res> get paymentTotals;
}

/// @nodoc
class _$GroupedSaleCopyWithImpl<$Res, $Val extends GroupedSale>
    implements $GroupedSaleCopyWith<$Res> {
  _$GroupedSaleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GroupedSale
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productName = null,
    Object? items = null,
    Object? totalQuantity = null,
    Object? totalAmount = null,
    Object? paymentTotals = null,
  }) {
    return _then(_value.copyWith(
      productName: null == productName
          ? _value.productName
          : productName // ignore: cast_nullable_to_non_nullable
              as String,
      items: null == items
          ? _value.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<GroupedSaleItem>,
      totalQuantity: null == totalQuantity
          ? _value.totalQuantity
          : totalQuantity // ignore: cast_nullable_to_non_nullable
              as double,
      totalAmount: null == totalAmount
          ? _value.totalAmount
          : totalAmount // ignore: cast_nullable_to_non_nullable
              as double,
      paymentTotals: null == paymentTotals
          ? _value.paymentTotals
          : paymentTotals // ignore: cast_nullable_to_non_nullable
              as PaymentTotals,
    ) as $Val);
  }

  /// Create a copy of GroupedSale
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PaymentTotalsCopyWith<$Res> get paymentTotals {
    return $PaymentTotalsCopyWith<$Res>(_value.paymentTotals, (value) {
      return _then(_value.copyWith(paymentTotals: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$GroupedSaleImplCopyWith<$Res>
    implements $GroupedSaleCopyWith<$Res> {
  factory _$$GroupedSaleImplCopyWith(
          _$GroupedSaleImpl value, $Res Function(_$GroupedSaleImpl) then) =
      __$$GroupedSaleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String productName,
      List<GroupedSaleItem> items,
      double totalQuantity,
      double totalAmount,
      PaymentTotals paymentTotals});

  @override
  $PaymentTotalsCopyWith<$Res> get paymentTotals;
}

/// @nodoc
class __$$GroupedSaleImplCopyWithImpl<$Res>
    extends _$GroupedSaleCopyWithImpl<$Res, _$GroupedSaleImpl>
    implements _$$GroupedSaleImplCopyWith<$Res> {
  __$$GroupedSaleImplCopyWithImpl(
      _$GroupedSaleImpl _value, $Res Function(_$GroupedSaleImpl) _then)
      : super(_value, _then);

  /// Create a copy of GroupedSale
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productName = null,
    Object? items = null,
    Object? totalQuantity = null,
    Object? totalAmount = null,
    Object? paymentTotals = null,
  }) {
    return _then(_$GroupedSaleImpl(
      productName: null == productName
          ? _value.productName
          : productName // ignore: cast_nullable_to_non_nullable
              as String,
      items: null == items
          ? _value._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<GroupedSaleItem>,
      totalQuantity: null == totalQuantity
          ? _value.totalQuantity
          : totalQuantity // ignore: cast_nullable_to_non_nullable
              as double,
      totalAmount: null == totalAmount
          ? _value.totalAmount
          : totalAmount // ignore: cast_nullable_to_non_nullable
              as double,
      paymentTotals: null == paymentTotals
          ? _value.paymentTotals
          : paymentTotals // ignore: cast_nullable_to_non_nullable
              as PaymentTotals,
    ));
  }
}

/// @nodoc

class _$GroupedSaleImpl extends _GroupedSale {
  const _$GroupedSaleImpl(
      {required this.productName,
      required final List<GroupedSaleItem> items,
      required this.totalQuantity,
      required this.totalAmount,
      required this.paymentTotals})
      : _items = items,
        super._();

  /// Display name for the group (e.g., "Rice 50 KG")
  @override
  final String productName;

  /// Individual sale items in this group
  final List<GroupedSaleItem> _items;

  /// Individual sale items in this group
  @override
  List<GroupedSaleItem> get items {
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_items);
  }

  /// Total quantity sold
  @override
  final double totalQuantity;

  /// Total amount for this group
  @override
  final double totalAmount;

  /// Payment method breakdown
  @override
  final PaymentTotals paymentTotals;

  @override
  String toString() {
    return 'GroupedSale(productName: $productName, items: $items, totalQuantity: $totalQuantity, totalAmount: $totalAmount, paymentTotals: $paymentTotals)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GroupedSaleImpl &&
            (identical(other.productName, productName) ||
                other.productName == productName) &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.totalQuantity, totalQuantity) ||
                other.totalQuantity == totalQuantity) &&
            (identical(other.totalAmount, totalAmount) ||
                other.totalAmount == totalAmount) &&
            (identical(other.paymentTotals, paymentTotals) ||
                other.paymentTotals == paymentTotals));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      productName,
      const DeepCollectionEquality().hash(_items),
      totalQuantity,
      totalAmount,
      paymentTotals);

  /// Create a copy of GroupedSale
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GroupedSaleImplCopyWith<_$GroupedSaleImpl> get copyWith =>
      __$$GroupedSaleImplCopyWithImpl<_$GroupedSaleImpl>(this, _$identity);
}

abstract class _GroupedSale extends GroupedSale {
  const factory _GroupedSale(
      {required final String productName,
      required final List<GroupedSaleItem> items,
      required final double totalQuantity,
      required final double totalAmount,
      required final PaymentTotals paymentTotals}) = _$GroupedSaleImpl;
  const _GroupedSale._() : super._();

  /// Display name for the group (e.g., "Rice 50 KG")
  @override
  String get productName;

  /// Individual sale items in this group
  @override
  List<GroupedSaleItem> get items;

  /// Total quantity sold
  @override
  double get totalQuantity;

  /// Total amount for this group
  @override
  double get totalAmount;

  /// Payment method breakdown
  @override
  PaymentTotals get paymentTotals;

  /// Create a copy of GroupedSale
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GroupedSaleImplCopyWith<_$GroupedSaleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
